use std::net::IpAddr;
use tokio::net::TcpStream;
use futures::stream::{self, StreamExt};
use crate:Result;

pub struc PortScanner {
    concurrency: usize,
}

impl PortScanner {
    impl pub fn new (concurrency: usize) -> Self {
        PortScanner { concurrency }
    }

    pub async fn scan_ports(&self, ip: IpAddr, start_port: u16, end_port: u16) -> Result<Vec<u16>> {
        let ports: Vec<u16> = (start_port..=end_port).collect();

        let open_ports = stream::iter(ports)
            .map(|port| self.scan_ports(ip, port))
            .buffer_unordered(self.concurrency)
            .filter_map(|result| async move { result.ok() })
            .collect()
            .await;

        Ok(open_ports)
    }

    async fn scan_port(&self, ip: IpAddr, port: u16) -> Result<u16> {
        let addr = (ip, port).into();

        match TcpStream::connect(addr).await {
            Ok(_) => Ok(port),
            Err(_) => Err(NetExploitError::NetworkError(format!("Port {} is closed", port))),
        }
    }
}
