use crate::models::{Target, Vulnerability};
use crate::utils::http_client::HttpClient;
use async_trait::async_trait;
use regex::Regex;

pub struct XssDetector;

#[async_trait]
impl super::VulnerabilityCheck for XssDetector {
    async fn check(&self, target: &Target, client: &HttpClient) -> Vec<Vulnerability> {
        let mut vulnerabilities = Vec::new();

        // Basic XSS payloads
        let payloads = vec![
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "<svg onload=alert('XSS')>",
            "javascript:alert('XSS')",
        ];

        for payload in payloads {
            let url = format!("{}?input={}", target.url, urlencoding::encode(payload));
            let response = client.get(&url).await.unwrap();
            let body = response.text().await.unwrap();

            // Check if the payload is reflected in the response
            if body.contains(payload) {
                vulnerabilities.push(Vulnerability {
                    name: "Cross-Site Scripting (XSS)".to_string(),
                    description: format!("Possible XSS vulnerability found with payload: {}", payload),
                    severity: "High".to_string(),
                    url: url.clone(),
                });
            }
        }

        // Check for absence of security headers
        let headers = response.headers();
        if !headers.contains_key("X-XSS-Protection") {
            vulnerabilities.push(Vulnerability {
                name: "Missing X-XSS-Protection Header".to_string(),
                description: "The X-XSS-Protection header is not set, which may leave the site more vulnerable to XSS attacks.".to_string(),
                severity: "Medium".to_string(),
                url: target.url.clone(),
            });
        }

        vulnerabilities
    }
}